#!/usr/bin/env python
# coding: utf-8

# This reads in cubes of dark-subtracted frames (where the slices of a given cube are
# at different fps), and uses both cubes to calculate gain

# (Generate cubes with CRED2_analysis_eckhart.ipynb)

import os
from os import listdir
from os.path import isfile,join
import numpy as np
import matplotlib.pyplot as plt
import glob
from astropy.io import fits

## BEGIN USER INPUTS

# This is just setting up my filepaths; you should replace them with wherever your folders are
# note that the gain should be the same for these
stem = "/Users/bandari/Documents/git.repos/gpi2_misc/data/"
#file_name_cube = stem + "linearity_noflat_High_gain.fits"
file_name_cube = stem + "linearity_subt_Low_gain_20221028.fits"

# define subarray to use for the calculations

x0, x1, y0, y1 = 5, -6, 200, 400
#x0, x1, y0, y1 = 240, 350, 330, 430
#x0, x1, y0, y1 = 500, 600, 300, 400
#x0, x1, y0, y1 = 4, -5, 4, -5

# first and last indices of arrays to consider when calculating gain (may take iteration)
index_0 = 0
index_1 = -1

# for low gain
array_fps = np.array([ 100,  150,  200,  250,  300,  350,  400,  450,  500,  550,  600, 650,  700,  750,  800,  850,  900,  950, 1000])

# for medium gain
#array_fps = np.array([ 250,  300,  350,  400,  450,  500,  550,  600,  650,  700,  750, 800,  850,  900,  950, 1000])

# for high gain
#array_fps = np.array([ 400,  500,  600,  700,  800,  900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000])

## END USER INPUTS

# Read in cubes of frames and find gain
# (note cubes are generated by CRED2_analysis_eckhart.ipynb)
# (Ref. McLean, chpt. 9, p. 322; or http://spiff.rit.edu/classes/phys445/lectures/gain/gain.html )

# loop over cubes (one cube per integration time) and find gain
# Ref. McLean, chpt. 9, p. 322; or http://spiff.rit.edu/classes/phys445/lectures/gain/gain.html
print("---------------------")
print("------- GAIN --------")

# open cube
hdul_0 = fits.open(file_name_cube)
cube_0 = hdul_0[0].data

# initialize arrays for variance, mean level
var_adu_array = np.zeros(np.shape(cube_0)[0])
avg_adu_array = np.zeros(np.shape(cube_0)[0])

#import ipdb; ipdb.set_trace()

# loop through slices, each of which represents a different fps
for num_slice in range(0,np.shape(cube_0)[0]):

    # find the difference between the slices
    #diff_slice = np.subtract(cube_0[num_slice,:,:],cube_1[num_slice,:,:])

    # remove NaNs and infs
    this_slice = cube_0[num_slice,:,:][y0:y1,x0:x1]
    this_slice_finite = this_slice[np.isfinite(this_slice)]

    # find variance equivalent to that of one slice: var = (stdev_diff**2)/2
    var_adu = np.power( np.std(this_slice_finite),2. )

    # find average count level (actually median here, to remove bad pix)
    avg_adu = np.median(this_slice_finite)

    # update arrays
    var_adu_array[num_slice] = var_adu
    avg_adu_array[num_slice] = avg_adu

    print(var_adu)


# calculate gain
coeffs_array = np.polyfit(x=avg_adu_array[index_0:index_1], y=var_adu_array[index_0:index_1], deg=1)
gain = np.divide(1.,coeffs_array[0])

# recalculate read noise based on gain value
noise_read = gain * np.sqrt(coeffs_array[1])

'''
plt.clf()
plt.imshow(this_slice, origin="lower")
plt.show()
'''
import ipdb; ipdb.set_trace()
plt.clf()
plt.plot(avg_adu_array,np.add(np.multiply(coeffs_array[0],avg_adu_array),coeffs_array[1]))
plt.scatter(avg_adu_array,var_adu_array)
plt.ylabel("Variance [ADU]")
plt.xlabel("Avg [ADU]")
plt.show()

print("Gain:",gain)
print("Read noise:",noise_read)
